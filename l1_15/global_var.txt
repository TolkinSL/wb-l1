var justString string

func someFunc() {
  v := createHugeString(1 << 10)
  justString = v[:100]
}

func main() {
  someFunc()
}

----------- Ответ:

В коде создаётся большая строка v. Потом мы берём первые 100 байт v[:100],
подстрока в Go не копирует данные — она хранит ссылку на тот же исходный массив.
Затем мы присваиваем эту подстроку глобальной переменной justString,
из-за чего в памяти остаётся вся большая строка, хотя реально нужно только 100 байт.

Это приводит к удержанию лишней памяти, потому что сборщик мусора не может освободить исходную строку,
пока глобальная переменная на неё ссылается.

Решение: нужно сделать явное копирование нужного фрагмента и предварительно проверить длину строки:

func someFunc() {
    v := createHugeString(1 << 10)
    if len(v) >= 100 {
        tmp := make([]byte, 100)
        copy(tmp, v[:100])
        justString = string(tmp)
    }
}